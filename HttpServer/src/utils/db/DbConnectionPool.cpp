#include "../../../include/utils/db/DbConnectionPool.h"
#include "../../../include/utils/db/DbException.h"
#include "mymuduo/Alogger.h"

namespace http
{

namespace db
{

void DbConnectionPool::init(const std::string& host, 
                            const std::string& user, 
                            const std::string& password,
                            const std::string& database,
                            size_t poolSize)
{
    host_ = host;
    user_ = user;
    password_ = password;
    database_ = database;
    initialized_ = false;
}

// 构造函数
DbConnectionPool::DbConnectionPool()
{
    checkThread_ = std::thread(&DbConnectionPool::checkConnections, this);
    checkThread_.detach();
}

// 析构函数
DbConnectionPool::~DbConnectionPool()
{
    // 把所有连接都清除掉
    std::lock_guard<std::mutex> lock(mutex_);
    while(!connections_.empty())
    {
        connections_.pop();
    }
    logger_->INFO("Database connection pool destroyed");
}

// 获取连接
std::shared_ptr<DbConnection> DbConnectionPool::getConnection()
{
    std::shared_ptr<DbConnection> conn;
    {
        std::unique_lock<std::mutex> lock(mutex_);
        while(connections_.empty())
        {
            if(!initialized_)
            {
                throw DbException("Connection pool not initialized");
            }
            logger_->INFO("Waiting for available connection...");
            cv_.wait(lock);
        }

        conn = connections_.front();
        connections_.pop();  // queue的pop()时出队头
    }

    try
    {
        // 在锁外检查连接
        if(!conn->ping())
        {
            logger_->WARN("Connection lost, attempting to reconnect...");
            conn->reconnect();
        }

        return std::shared_ptr<DbConnection>(conn.get(), 
            [this, conn](DbConnection*){
                std::lock_guard<std::mutex> lock(mutex_);
                connections_.push(conn);
                cv_.notify_one();
            }
        );
    }
    catch(const std::exception& e)
    {
        logger_->ERROR(std::string("Failed to get connection: ") + e.what());
        {
            std::lock_guard<std::mutex> lock(mutex_);
            connections_.push(conn);
            cv_.notify_one();
        }
        throw;
    }
    
}

std::shared_ptr<DbConnection> DbConnectionPool::createConnection()
{
    return std::make_shared<DbConnection>(host_, user_, password_, database_);
}

// 修改检查连接的函数
void DbConnectionPool::checkConnections()
{
    while(true)
    {
        try
        {
            std::vector<std::shared_ptr<DbConnection>> connsToCheck;
            {
                std::unique_lock<std::mutex> lock(mutex_);
                if(connections_.empty())
                {
                    std::this_thread::sleep_for(std::chrono::seconds(1));
                    continue;
                }

                // 把connections_中的connection全部复制一份到connsToCheck;
                auto temp = connections_;
                while(!temp.empty())
                {
                    connsToCheck.push_back(temp.front());
                    temp.pop();
                }
            }

            // 逐个检查connection,如果ping不通，就重新连接
            for(auto &conn: connsToCheck)
            {
                if(!conn->ping())
                {
                    try
                    {
                        conn->reconnect();
                    }
                    catch(const std::exception& e)
                    {
                        logger_->ERROR(std::string("Failed to reconnect: ") + e.what());
                    }
                    
                }
            }

            std::this_thread::sleep_for(std::chrono::seconds(60));
        }
        catch(const std::exception& e)
        {
            logger_->ERROR(std::string("Error in check thread: ") + e.what());
            std::this_thread::sleep_for(std::chrono::seconds(5));
        }
    }
}


}

}